/* Copyright 2019 Husky Data Lab, CUHK

Authors: Created by Chenghuan Huang (chhuang@cse.cuhk.edu.hk)
         Modified by Changji LI (cjli@cse.cuhk.edu.hk)
*/

#pragma once

#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "tbb/concurrent_queue.h"

#include "layout/data_storage.hpp"
#include "utils/config.hpp"
#include "utils/mymath.hpp"
#include "utils/tid_mapper.hpp"

/**
 * ACTIVE: Task is active and could be executed anytime
 * EMPTY: The task is a empty task generated by its downstream task (To be decided)
 * INVALID: The task is no more valid, should be deleted
 */
enum class TaskStatus {
    ACTIVE,
    EMPTY,
    INVALID,
    BLOCKED
};

/* AbstractGCTask is the parent class for all GC tasks. */
class AbstractGCTask {
 public:
    // Cost for completing the task
    // different cost model for different task
    int cost_ = 1;
    int COST_THRESHOLD;

    AbstractGCTask(){}
    AbstractGCTask(int cost) : cost_(cost) {}
};

/* IndependentGCTask is the parent class of GC tasks without dependency.
 */
class IndependentGCTask : public AbstractGCTask {
 public:
    IndependentGCTask(){}
    IndependentGCTask(int cost) : AbstractGCTask(cost) {}

    // Task Status in IndependentGCTask will
    // be always active
    const TaskStatus task_status = TaskStatus::ACTIVE;
};

/* DependentGCTask is the parent class of GC tasks with dependency.
 * Each dependent task is a vertex in the GCTaskDAG.
 * Thus, DependentGCTask need extra members and functions to support the features as a
 * vertex in the GCTaskDAG.
 */
class DependentGCTask : public AbstractGCTask {
 public:
    DependentGCTask() { task_status = TaskStatus::ACTIVE; blocked_count_ = 0; }
    DependentGCTask(int cost) : AbstractGCTask(cost) { task_status = TaskStatus::ACTIVE; blocked_count_ = 0; }
    ~DependentGCTask() {}

    // upstream_tasks_ stores the incoming neighbors (parent tasks)
    // When READY -> PUSHED, all of its upstream tasks's blocked_count_ will be increased by 1 (recursive).
    unordered_set<DependentGCTask*> upstream_tasks_;

    // downstream_tasks_ stores the incoming neighbors (parent tasks)
    // When EMPTY -> READY, all of its READY downstream tasks will be permenently deleted (recursive).
    unordered_set<DependentGCTask*> downstream_tasks_;

    // Task Status to indicate whether the task is
    // active, invalid or other status
    TaskStatus task_status;

    // How many dependent tasks has been pushed out.
    // Notice that a task can be EMPTY when blocked_count_ > 0
    int blocked_count_;
};

// Erase a specific vid on vertex_map_
class EraseVTask : public IndependentGCTask {
 public:
    vid_t target;
    EraseVTask(vid_t target_) : target(target_) {}
};

// Perform GC on V_MVCC
// This task will always exists with EraseVTask
class VMVCCGCTask : public IndependentGCTask {
 public:
    VertexMVCCItem* target;
    VMVCCGCTask(VertexMVCCItem* target_, int cost) : target(target_), IndependentGCTask(cost) {}
};

// Free a VPRowList
class VPRowListGCTask : public DependentGCTask {
 public:
    PropertyRowList<VertexPropertyRow>* target;  // Task context
    vid_t id;  // Task id

    VPRowListGCTask(PropertyRowList<VertexPropertyRow>* target_, vid_t id_) : target(target_), id(id_) {}
};

// Defrag a VPRowList
class VPRowListDefragTask : public DependentGCTask {
 public:
    PropertyRowList<VertexPropertyRow>* target;  // Task context
    vid_t id;  // Task id

    VPRowListDefragTask(vid_t id_, PropertyRowList<VertexPropertyRow>* target_, int cost) : id(id_), target(target_), DependentGCTask(cost) {}
};

// Free a TopoRowList
class TopoRowListGCTask : public DependentGCTask {
 public:
    TopologyRowList* target;  // Task context
    vid_t id;  // Task id

    TopoRowListGCTask(){}
    TopoRowListGCTask(TopologyRowList* target_, vid_t id_) : target(target_), id(id_) {}
};

// Defrag a TopoRowList
class TopoRowListDefragTask : public DependentGCTask {
 public:
    TopologyRowList* target;  // Task context
    vid_t id;  // Task id

    TopoRowListDefragTask(TopologyRowList* target_, vid_t id_, int cost) : target(target_), id(id_), DependentGCTask(cost) {}
};

// Perform GC on VP_MVCC
class VPMVCCGCTask : public IndependentGCTask {
 public:
    VPropertyMVCCItem* target;

    VPMVCCGCTask(VPropertyMVCCItem* target_, int cost) : target(target_), IndependentGCTask(cost) {}
};

// Erase a specific eid on out_e_map_
// TODO : Merge into EdgeMVCCListGC
class EraseOutETask : public IndependentGCTask {
 public:
    eid_t target;
};

// Erase a specific eid on in_e_map_
class EraseInETask : public IndependentGCTask {
 public:
    eid_t target;
};

struct CompoundEPRowListID {
    eid_t eid;
    PropertyRowList<EdgePropertyRow>* ptr;

    CompoundEPRowListID(){}
    CompoundEPRowListID(eid_t eid_, PropertyRowList<EdgePropertyRow>* ptr_) : eid(eid_), ptr(ptr_) {}

    vid_t GetAttachedVid() {
        return eid.out_v;  // src_v
    }

    bool operator== (const CompoundEPRowListID& right_id) const {
        return (eid == right_id.eid && ptr == right_id.ptr);
    }
};

struct CompoundEPRowListIDHash {
    size_t operator()(const CompoundEPRowListID& _r) const {
        return mymath::hash_u64(_r.eid.value() ^ (uint64_t)_r.ptr);
    }
};

struct VidHash {
    size_t operator()(const vid_t& _r) const {
        return mymath::hash_u64(_r.value());
    }
};

struct EidHash {
    size_t operator()(const eid_t& _r) const {
        return mymath::hash_u64(_r.value());
    }
};

class EMVCCGCTask : public IndependentGCTask {
 public:
    EdgeMVCCItem* target;
    eid_t id;

    EMVCCGCTask(eid_t& id_, EdgeMVCCItem* target_, int cost) : target(target_), id(id_), IndependentGCTask(cost) {}
};

// Delete Whole EPRowList
class EPRowListGCTask : public DependentGCTask {
 public:
    PropertyRowList<EdgePropertyRow>* target;  // Task context
    CompoundEPRowListID id;  // Task id

    EPRowListGCTask(){}
    EPRowListGCTask(eid_t& eid, PropertyRowList<EdgePropertyRow>* target_) : target(target_) {
        id = CompoundEPRowListID(eid, target_);
    }
};

// Defrag a EPRowList
class EPRowListDefragTask : public DependentGCTask {
 public:
    PropertyRowList<EdgePropertyRow>* target;  // Task context
    CompoundEPRowListID id;  // Task id

    EPRowListDefragTask(eid_t& eid, PropertyRowList<EdgePropertyRow>* target_, int cost) : target(target_), DependentGCTask(cost) {
        id = CompoundEPRowListID(eid, target_);
    }
};

// Perform GC on EP_MVCC
class EPMVCCGCTask : public IndependentGCTask {
 public:
    EPropertyMVCCItem* target;

    EPMVCCGCTask(EPropertyMVCCItem* target_, int cost) : target(target_), IndependentGCTask(cost) {}
};

template <class GCTaskT>
class GCJob {
 public:
    vector<GCTaskT> tasks_;
    unordered_set<GCTaskT*> tasks_ptr;
    // sum of cost of all tasks
    int sum_of_cost_;
    int blocked_conut;

    GCJob() {
        sum_of_cost_ = 0;
        blocked_conut = 0;
    }

    void AddTask(GCTaskT task) {
        tasks_.emplace_back(task);
        tasks_ptr.emplace(&task);
        if (task.task_status == TaskStatus::ACTIVE) {
            sum_of_cost_ += task.cost_;
        } else if (task.task_status == TaskStatus::BLOCKED) {
            blocked_conut += 1;
        }
    }

    bool SetTaskInvalid(GCTaskT* target_task) {
        if (tasks_ptr.find(target_task) == tasks_ptr.end()) {
            // No such task 
            return false;
        }

        target_task->task_status = TaskStatus::INVALID;
        sum_of_cost_ -= target_task->cost_;
        return true;
    }

    // Check whether a Job is ready to be consumed
    bool isReady() {}

    bool taskExists(GCTaskT* t_ptr) {
        if (tasks_ptr.find(t_ptr) != tasks_ptr.end()) {
            return true;
        }
        return false;
    }
};
