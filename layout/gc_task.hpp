/* Copyright 2019 Husky Data Lab, CUHK

Authors: Created by Chenghuan Huang (chhuang@cse.cuhk.edu.hk)
         Modified by Changji LI (cjli@cse.cuhk.edu.hk)
*/

#pragma once

#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "tbb/concurrent_queue.h"

#include "layout/data_storage.hpp"
#include "utils/config.hpp"
#include "utils/mymath.hpp"
#include "utils/tid_mapper.hpp"

/* AbstractGCTask is the parent class for all GC tasks. */
class AbstractGCTask {
 public:
    // Cost for completing the task
    // different cost model for different task
    int cost_ = 1;
    int COST_THRESHOLD;
};

/* IndependentGCTask is the parent class of GC tasks without dependency.
 */
class IndependentGCTask : public AbstractGCTask {
};

/* DependentGCTask is the parent class of GC tasks with dependency.
 * Each dependent task is a vertex in the GCTaskDAG.
 * Thus, DependentGCTask need extra members and functions to support the features as a
 * vertex in the GCTaskDAG.
 */
class DependentGCTask : public AbstractGCTask {
 public:
    // upstream_tasks_ and downstream_tasks_ are used to maintain the topology of the DAG.

    // upstream_tasks_ stores the incoming neighbors (parent tasks)
    // When READY -> PUSHED, all of its upstream tasks's blocked_count_ will be increased by 1 (recursive).
    // unordered_set<DependentGCTask*> upstream_tasks_;

    // downstream_tasks_ stores the incoming neighbors (parent tasks)
    // When EMPTY -> READY, all of its READY downstream tasks will be permenently deleted (recursive).
    // unordered_set<DependentGCTask*> downstream_tasks_;

    /**
     * READY: The task is ready to be pushed to the GCExecutor (To be decided)
     * PUSHED: The task has already been pushed to the GCExecutor (To be decided) 
     * EMPTY: The task is a empty task generated by its downstream task (To be decided)
     * INVALID: The task is no more valid, should be deleted
     */
    enum class TaskStatus {
        READY,
        PUSHED,
        EMPTY,
        INVALID
    };

    TaskStatus task_status_;

    // How many downstream tasks has been pushed out.
    // Notice that a task can be EMPTY or READY when blocked_count_ > 0
    // However, PUSHED and blocked_count_ > 0 is not allowed. (Error occurs)
    // int blocked_count_;

    /* DAG should not be here, better in gc_worker */
    // static GCTaskDAG* gc_dag_;

    // Called when the task is removed in DAG.
    // virtual void PropagateDeletion() = 0;
    // Called when the task need to be blocked;
    // sum_of_cost_ will not count blocked tasks on.
    // virtual void PropagateBlocking() = 0;
};

/* For each type of GC tasks, a static integer "sum_of_cost_" will be used to store 
 *
 */

// Erase a specific vid on vertex_map_
class EraseVTask : public IndependentGCTask {
 public:
    vid_t target;
};

// Perform GC on V_MVCC
// This task will always exists with EraseVTask
class VMVCCGCTask : public IndependentGCTask {
 public:
    VertexMVCCItem* target;
};

// Free a VPRowList
class VPRowListGCTask : public DependentGCTask {
 public:
    // Task context
    PropertyRowList<VertexPropertyRow>* target;
    // Task id
    vid_t id_;
};

// Defrag a VPRowList
class VPRowListDefragTask : public DependentGCTask {
 public:
    // Task context
    PropertyRowList<VertexPropertyRow>* target;
    // Task id
    vid_t id_;

    // TODO: Should record the Invalid cells
};

// Free a TopoRowList
class TopoRowListGCTask : public DependentGCTask {
 public:
    // Task context
    TopologyRowList* target;
    // Task id
    vid_t id_;
};

// Defrag a TopoRowList
class TopoRowListDefragTask : public DependentGCTask {
 public:
    // Task context
    TopologyRowList* target;
    // Task id
    vid_t id_;
};

// Perform GC on VP_MVCC
class VPMVCCGCTask : public IndependentGCTask {
 public:
    VPropertyMVCCItem* target;
};

// Erase a specific eid on out_e_map_
// TODO : Merge into EdgeMVCCListGC
class EraseOutETask : public IndependentGCTask {
 public:
    eid_t target;
};

// Erase a specific eid on in_e_map_
class EraseInETask : public IndependentGCTask {
 public:
    eid_t target;
};

// Perform GC on E_MVCC without EPRowList
class EmptyEdgeGCTask : public IndependentGCTask {
 public:
    EdgeMVCCItem* target;
};

struct CompoundEPRowListID {
    eid_t eid;
    PropertyRowList<EdgePropertyRow>* ptr;

    vid_t GetAttachedVid() {
        return eid.out_v;  // src_v
    }

    bool operator== (const CompoundEPRowListID& right_id) const {
        return (eid == right_id.eid && ptr == right_id.ptr);
    }
};

struct CompoundEPRowListIDHash {
    size_t operator()(const CompoundEPRowListID& _r) const {
        return mymath::hash_u64(_r.eid.value() ^ (uint64_t)_r.ptr);
    }
};

struct VidHash {
    size_t operator()(const vid_t& _r) const {
        return mymath::hash_u64(_r.value());
    }
};

// Perform GC on E_MVCC with EPRowList
class EdgeEntityGCTask : public DependentGCTask {
 public:
    // Task context
    EdgeMVCCItem* target;
    // Task id
    CompoundEPRowListID id_;
};

// Defrag a EPRowList
class EPRowListDefragTask : public DependentGCTask {
 public:
    // Task context
    EdgeMVCCItem* target;
    // Task id
    CompoundEPRowListID id_;
};

// Perform GC on EP_MVCC
class EPMVCCGCTask : public IndependentGCTask {
 public:
    EPropertyMVCCItem* target;
};

template <class GCTaskT>
class GCJob {
 public:
    vector<GCTaskT*> tasks_;
    // vector<AbstractGCTask*> tasks_;
    // sum of cost of all tasks
    int sum_of_cost_;

    GCJob() {
        sum_of_cost_ = 0;
    }

    void AddTask(GCTaskT * task) {
        tasks_.emplace_back(task);
        sum_of_cost_ += task->cost; 
    }

    // Check whether a Job is ready to be consumed
    bool isReady() {
    }
};
