// Copyright 2020 BigGraph Team @ Husky Data Lab, CUHK
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "tbb/concurrent_queue.h"

#include "base/type.hpp"
#include "layout/data_storage.hpp"
#include "utils/config.hpp"
#include "utils/mymath.hpp"
#include "utils/tid_pool_manager.hpp"


/* =====================Struct Region============================== */

/**
 * ACTIVE: Task is active and could be executed anytime
 * EMPTY: The task is an empty task generated by its downstream task
 * INVALID: The task is no more valid
 * BLOCKED: Tha task is blocked by some downstream tasks, need to wait downstream task complete
 * PUSHED: The task is a previous ACTIVE task that has been pushed to GCConsumer
 */
enum class TaskStatus {
    ACTIVE,
    EMPTY,
    INVALID,
    BLOCKED,
    PUSHED,
    COUNT,
};

enum class DepGCTaskType {
    TOPO_ROW_LIST_GC,
    TOPO_ROW_LIST_DEFRAG,
    VP_ROW_LIST_GC,
    VP_ROW_LIST_DEFRAG,
    EP_ROW_LIST_GC,
    EP_ROW_LIST_DEFRAG,
    COUNT,
};

extern const unordered_map<TaskStatus, string, EnumClassHash<TaskStatus>> task_status_string_map;
extern const unordered_map<DepGCTaskType, string, EnumClassHash<DepGCTaskType>> dep_gc_task_type_string_map;

// for StatusExpert's gc statistics
void IncreaseTaskStatusCounter(DepGCTaskType type, TaskStatus status);
void DecreaseTaskStatusCounter(DepGCTaskType type, TaskStatus status);

// ID used for edge related dependent task
struct CompoundEPRowListID {
    eid_t eid;
    PropertyRowList<EdgePropertyRow>* ptr;

    CompoundEPRowListID() {}
    CompoundEPRowListID(eid_t eid_, PropertyRowList<EdgePropertyRow>* ptr_) : eid(eid_), ptr(ptr_) {}

    vid_t GetAttachedVid() {
        return eid.src_v;
    }

    bool operator== (const CompoundEPRowListID& right_id) const {
        return (eid == right_id.eid && ptr == right_id.ptr);
    }
};

struct CompoundEPRowListIDHash {
    size_t operator()(const CompoundEPRowListID& _r) const {
        return mymath::hash_u64(_r.eid.value() ^ (uint64_t)_r.ptr);
    }
};

struct VidHash {
    size_t operator()(const vid_t& _r) const {
        return mymath::hash_u64(_r.value());
    }
};

struct EidHash {
    size_t operator()(const eid_t& _r) const {
        return mymath::hash_u64(_r.value());
    }
};

/* =====================Task Region============================== */

/* AbstractGCTask is the parent class for all GC tasks. */
class AbstractGCTask {
 public:
    // Cost for completing the task
    // different cost model for different task
    int cost_ = 1;

    AbstractGCTask() {}
    AbstractGCTask(int cost) : cost_(cost) {}
};

class IndependentGCTask : public AbstractGCTask {
 public:
    IndependentGCTask() {}
    IndependentGCTask(int cost) : AbstractGCTask(cost) {}
};

/* DependentGCTask is the parent class of GC tasks with dependency.
 * Each dependent task is a vertex in the GCTaskDAG.
 * Thus, DependentGCTask need extra members and functions to support the features as a
 * vertex in the GCTaskDAG.
 */
class DependentGCTask : public AbstractGCTask {
 public:
    DependentGCTask() { blocked_count_ = 0; }
    DependentGCTask(int cost) : AbstractGCTask(cost) { blocked_count_ = 0; }
    virtual ~DependentGCTask() {}


    // upstream_tasks_ stores the incoming neighbors (parent tasks)
    unordered_set<DependentGCTask*> upstream_tasks_;

    // downstream_tasks_ stores the outgoing neighbors (child tasks)
    unordered_set<DependentGCTask*> downstream_tasks_;

    // There must be an id for each dependent task which will
    // be used as key in dependent map

    virtual string GetTaskTypeStr() {
        return "DependentGCTask";
    }

    string GetTaskStatusStr() {
        return task_status_string_map.at(task_status_);
    }

    string GetTaskInfoStr(bool print_adj = true) {
        string ret = " status:" + GetTaskStatusStr() + ", type:" + GetTaskTypeStr();
        if (print_adj) {
            string adj_info = "upstream: ";
            for (auto* upstream_task : upstream_tasks_)
                adj_info += "{" + upstream_task->GetTaskInfoStr(false) + "} ";

            adj_info += ", downstream: ";
            for (auto* downstream_task : downstream_tasks_)
                adj_info += "{" + downstream_task->GetTaskInfoStr(false) + "} ";
            ret += "adj: [" + adj_info + "]";
        }
        return ret;
    }

    virtual DepGCTaskType GetTaskType() = 0;

    void IncreaseBLockedCount() {
        blocked_count_++;
    }

    // only call this in DependentGCJob::ReduceTaskBlockCount()
    void DecreaseBlockedCount() {
        blocked_count_--;
    }

    int GetBlockedCount() {
        return blocked_count_;
    }

    TaskStatus GetTaskStatus() {
        return task_status_;
    }

    void SetTaskStatus(TaskStatus task_status) {
        DecreaseTaskStatusCounter(GetTaskType(), task_status_);
        task_status_ = task_status;
        IncreaseTaskStatusCounter(GetTaskType(), task_status_);
    }

 private:
    TaskStatus task_status_ = TaskStatus::ACTIVE;

    // How many dependent tasks has been pushed out.
    // Will be maintained only when a task is not EMPTY and added to a job.
    int blocked_count_ = 0;
};

// Erase a specific vid on vertex_map_
class EraseVTask : public IndependentGCTask {
 public:
    vid_t target;
    EraseVTask(vid_t target_) : target(target_) {}
};

// Erase a specific eid on out_e_map_
class EraseOutETask : public IndependentGCTask {
 public:
    eid_t target;

    EraseOutETask(eid_t& eid) : target(eid) {}
};

// Erase a specific eid on in_e_map_
class EraseInETask : public IndependentGCTask {
 public:
    eid_t target;

    EraseInETask(eid_t& eid) : target(eid) {}
};

// Perform GC on V_MVCC
class VMVCCGCTask : public IndependentGCTask {
 public:
    VertexMVCCItem* target;
    VMVCCGCTask(VertexMVCCItem* target_, int cost) : target(target_), IndependentGCTask(cost) {}
};

// Perform GC on VP_MVCC
class VPMVCCGCTask : public IndependentGCTask {
 public:
    VPropertyMVCCItem* target;

    VPMVCCGCTask(VPropertyMVCCItem* target_, int cost) : target(target_), IndependentGCTask(cost) {}
};

// Perform GC on EMVCC
class EMVCCGCTask : public IndependentGCTask {
 public:
    EdgeMVCCItem* target;
    eid_t id;

    EMVCCGCTask(eid_t& id_, EdgeMVCCItem* target_, int cost) : target(target_), id(id_), IndependentGCTask(cost) {}
};

// Perform GC on EP_MVCC
class EPMVCCGCTask : public IndependentGCTask {
 public:
    EPropertyMVCCItem* target;

    EPMVCCGCTask(EPropertyMVCCItem* target_, int cost) : target(target_), IndependentGCTask(cost) {}
};

// Perform GC on IndexStore:TopoIndex
class TopoIndexGCTask : public IndependentGCTask {
 public:
    Element_T element_type;

    // The cost of TopoIndexGC is always 1 which makes sure
    // the task will be pushed out immediately.
    TopoIndexGCTask(Element_T element_type_) : element_type(element_type_), IndependentGCTask(1) {}
};

// Perform GC on IndexStore:PropIndex
class PropIndexGCTask : public IndependentGCTask {
 public:
    Element_T element_type;
    int pid;

    PropIndexGCTask(Element_T element_type_, int pid_, int cost) :
        element_type(element_type_), pid(pid_), IndependentGCTask(cost) {}
};

// Perform GC on RCT
class RCTGCTask : public IndependentGCTask {
 public:
    RCTGCTask(int cost) : IndependentGCTask(cost) {}
};

// Preform GC on TrxStatusTable
class TrxStatusTableGCTask : public IndependentGCTask {
 public:
    TrxStatusTableGCTask(int cost) : IndependentGCTask(cost) {}
};

// Free a TopoRowList
class TopoRowListGCTask : public DependentGCTask {
 public:
    virtual string GetTaskTypeStr() override {
        return "TopoRowListGCTask";
    }

    virtual DepGCTaskType GetTaskType() override {
        return DepGCTaskType::TOPO_ROW_LIST_GC;
    }

    TopologyRowList* target = nullptr;
    vid_t id;

    TopoRowListGCTask(vid_t id_, TopologyRowList* target_) : target(target_), id(id_) {
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::ACTIVE);
    }
    TopoRowListGCTask() = delete;
    ~TopoRowListGCTask() override {
        DecreaseTaskStatusCounter(GetTaskType(), GetTaskStatus());
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::COUNT);
    }
};

// Defrag a TopoRowList
class TopoRowListDefragTask : public DependentGCTask {
 public:
    virtual string GetTaskTypeStr() override {
        return "TopoRowListDefragTask";
    }

    virtual DepGCTaskType GetTaskType() override {
        return DepGCTaskType::TOPO_ROW_LIST_DEFRAG;
    }

    TopologyRowList* target = nullptr;
    vid_t id;

    TopoRowListDefragTask(vid_t id_, TopologyRowList* target_, int cost) :
        target(target_), id(id_), DependentGCTask(cost) {
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::ACTIVE);
    }
    TopoRowListDefragTask() = delete;
    ~TopoRowListDefragTask() override {
        DecreaseTaskStatusCounter(GetTaskType(), GetTaskStatus());
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::COUNT);
    }
};

// Free a VPRowList
class VPRowListGCTask : public DependentGCTask {
 public:
    virtual string GetTaskTypeStr() override {
        return "VPRowListGCTask";
    }

    virtual DepGCTaskType GetTaskType() override {
        return DepGCTaskType::VP_ROW_LIST_GC;
    }

    PropertyRowList<VertexPropertyRow>* target = nullptr;
    vid_t id;

    VPRowListGCTask(vid_t id_, PropertyRowList<VertexPropertyRow>* target_) : target(target_), id(id_) {
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::ACTIVE);
    }
    VPRowListGCTask() = delete;
    ~VPRowListGCTask() override {
        DecreaseTaskStatusCounter(GetTaskType(), GetTaskStatus());
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::COUNT);
    }
};

// Defrag a VPRowList
class VPRowListDefragTask : public DependentGCTask {
 public:
    virtual string GetTaskTypeStr() override {
        return "VPRowListDefragTask";
    }

    virtual DepGCTaskType GetTaskType() override {
        return DepGCTaskType::VP_ROW_LIST_DEFRAG;
    }

    PropertyRowList<VertexPropertyRow>* target = nullptr;
    vid_t id;

    VPRowListDefragTask(vid_t id_, PropertyRowList<VertexPropertyRow>* target_, int cost) :
        id(id_), target(target_), DependentGCTask(cost) {
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::ACTIVE);
    }
    VPRowListDefragTask() = delete;
    ~VPRowListDefragTask() override {
        DecreaseTaskStatusCounter(GetTaskType(), GetTaskStatus());
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::COUNT);
    }
};

// Free a EPRowList
class EPRowListGCTask : public DependentGCTask {
 public:
    virtual string GetTaskTypeStr() override {
        return "EPRowListGCTask";
    }

    virtual DepGCTaskType GetTaskType() override {
        return DepGCTaskType::EP_ROW_LIST_GC;
    }

    PropertyRowList<EdgePropertyRow>* target = nullptr;
    CompoundEPRowListID id;

    EPRowListGCTask(const CompoundEPRowListID& id_, PropertyRowList<EdgePropertyRow>* target_) : id(id_), target(target_) {
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::ACTIVE);
    }
    EPRowListGCTask() = delete;
    ~EPRowListGCTask() override {
        DecreaseTaskStatusCounter(GetTaskType(), GetTaskStatus());
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::COUNT);
    }
};

// Defrag a EPRowList
class EPRowListDefragTask : public DependentGCTask {
 public:
    virtual string GetTaskTypeStr() override {
        return "EPRowListDefragTask";
    }

    virtual DepGCTaskType GetTaskType() override {
        return DepGCTaskType::EP_ROW_LIST_DEFRAG;
    }

    PropertyRowList<EdgePropertyRow>* target = nullptr;
    CompoundEPRowListID id;

    EPRowListDefragTask(const CompoundEPRowListID& id_, PropertyRowList<EdgePropertyRow>* target_, int cost) :
        id(id_), target(target_), DependentGCTask(cost) {
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::ACTIVE);
    }
    EPRowListDefragTask() = delete;
    ~EPRowListDefragTask() override {
        DecreaseTaskStatusCounter(GetTaskType(), GetTaskStatus());
        IncreaseTaskStatusCounter(GetTaskType(), TaskStatus::COUNT);
    }
};

/* =====================Job Region============================== */

class AbstractGCJob {
 public:
    // sum of cost of all tasks
    int sum_of_cost_;
    // Threshold for job to push out
    int COST_THRESHOLD;

    JobType job_t_;

    AbstractGCJob(JobType _job_t, int thres) : job_t_(_job_t), COST_THRESHOLD(thres) {
        sum_of_cost_ = 0;
    }

    virtual ~AbstractGCJob() {}

    // Check whether a Job is ready to be consumed
    virtual bool isReady() = 0;
    virtual void Clear() = 0;
};

class IndependentGCJob : public AbstractGCJob {
 public:
    vector<IndependentGCTask*> tasks_;

    IndependentGCJob(JobType job_t, int thres) : AbstractGCJob(job_t, thres) {}
    ~IndependentGCJob() override { for (auto t : tasks_) delete t; }

    void AddTask(IndependentGCTask* task) {
        tasks_.emplace_back(task);
        sum_of_cost_ += task->cost_;
    }

    void Clear() override {
        sum_of_cost_ = 0;
        tasks_.clear();
    }

    bool isReady() override {
        return sum_of_cost_ >= COST_THRESHOLD;
    }

    bool isEmpty() {
        return tasks_.size() == 0;
    }

    string DebugString() {
        string ret = "#Tasks: " + to_string(tasks_.size());
        ret += " Sum_Of_Cost: " + to_string(sum_of_cost_);
        ret += " CostThres: " + to_string(COST_THRESHOLD);
        return ret;
    }
};

// Never find a task in a job.
class DependentGCJob : public AbstractGCJob {
 public:
    // sum of blocked tasks
    int sum_blocked_count_;
    vector<DependentGCTask*> tasks_;

    DependentGCJob(JobType job_t, int thres) : AbstractGCJob(job_t, thres) {}
    ~DependentGCJob() override { for (auto t : tasks_) delete t; }

    void Clear() override {
        sum_of_cost_ = 0;
        sum_blocked_count_ = 0;
        tasks_.clear();
    }

    bool isReady() override {
        return ((sum_of_cost_ >= COST_THRESHOLD) && (sum_blocked_count_ == 0));
    }

    bool isEmpty() {
        return tasks_.size() == 0;
    }

    void AddTask(DependentGCTask* task) {
        tasks_.emplace_back(task);
        sum_of_cost_ += task->cost_;
        sum_blocked_count_ += task->GetBlockedCount();
    }

    // called when a EMPTY upstream task of this task is substanitiated
    void SetTaskInvalid(DependentGCTask* task) {
        task->SetTaskStatus(TaskStatus::INVALID);
        sum_of_cost_ -= task->cost_;
    }

    // called when PUSHED downstream tasks is finished
    void ReduceTaskBlockCount(DependentGCTask* task) {
        task->DecreaseBlockedCount();
        if (task->GetBlockedCount() == 0) {
            task->SetTaskStatus(TaskStatus::ACTIVE);
        }

        sum_blocked_count_--;
    }

    string DebugString() {
        string ret = "#Tasks: " + to_string(tasks_.size());
        ret += " Sum_Of_Cost: " + to_string(sum_of_cost_);
        ret += " Blocked_Count: " + to_string(sum_blocked_count_);
        ret += " CostThres: " + to_string(COST_THRESHOLD);
        return ret;
    }
};

class EraseVJob : public IndependentGCJob {
 public:
    // Currently, threshold for job to be pushed
    // out is hard-coded and maybe put them into
    // config or to be calculated
    EraseVJob() : IndependentGCJob(JobType::EraseV, Config::GetInstance()->Erase_V_Task_THRESHOLD) {}
};

class EraseOutEJob : public IndependentGCJob {
 public:
    EraseOutEJob() : IndependentGCJob(JobType::EraseOutE, Config::GetInstance()->Erase_OUTE_Task_THRESHOLD) {}
};

class EraseInEJob : public IndependentGCJob {
 public:
    EraseInEJob() : IndependentGCJob(JobType::EraseInE, Config::GetInstance()->Erase_INE_Task_THRESHOLD) {}
};

class VMVCCGCJob : public IndependentGCJob {
 public:
    VMVCCGCJob() : IndependentGCJob(JobType::VMVCCGC, Config::GetInstance()->VMVCC_GC_Task_THRESHOLD) {}
};

class VPMVCCGCJob : public IndependentGCJob {
 public:
    VPMVCCGCJob() : IndependentGCJob(JobType::VPMVCCGC, Config::GetInstance()->VPMVCC_GC_Task_THRESHOLD) {}
};

class EPMVCCGCJob : public IndependentGCJob {
 public:
    EPMVCCGCJob() : IndependentGCJob(JobType::EPMVCCGC, Config::GetInstance()->EPMVCC_GC_Task_THRESHOLD) {}
};

class EMVCCGCJob : public IndependentGCJob {
 public:
    EMVCCGCJob() : IndependentGCJob(JobType::EMVCCGC, Config::GetInstance()->EMVCC_GC_Task_THRESHOLD) {}
};

class TopoIndexGCJob : public IndependentGCJob {
 public:
    TopoIndexGCJob() : IndependentGCJob(JobType::TopoIndexGC, Config::GetInstance()->Topo_Index_GC_Task_THRESHOLD) {}
};

class PropIndexGCJob : public IndependentGCJob {
 public:
    PropIndexGCJob() : IndependentGCJob(JobType::PropIndexGC, Config::GetInstance()->Prop_Index_GC_Task_THRESHOLD) {}
};

class RCTGCJob : public IndependentGCJob {
 public:
    RCTGCJob() : IndependentGCJob(JobType::RCTGC, Config::GetInstance()->RCT_GC_Task_THRESHOLD) {}
};

class TrxStatusTableGCJob : public IndependentGCJob {
 public:
    // Make threshold same with RCTGCJob, since we spawn rct_gc_task and trx_status_table_gc_tasks
    // together to avoid scanning status table which is expensive to scan;
    TrxStatusTableGCJob() : IndependentGCJob(JobType::TrxStatusTableGC, Config::GetInstance()->RCT_GC_Task_THRESHOLD) {}
};

class TopoRowListGCJob : public DependentGCJob {
 public:
    TopoRowListGCJob() : DependentGCJob(JobType::TopoRowGC, Config::GetInstance()->Topo_Row_GC_Task_THRESHOLD) {}
};

class TopoRowListDefragJob : public DependentGCJob {
 public:
    TopoRowListDefragJob() : DependentGCJob(JobType::TopoRowDefrag, Config::GetInstance()->Topo_Row_Defrag_Task_THRESHOLD) {}
};

class VPRowListGCJob : public DependentGCJob {
 public:
    VPRowListGCJob() : DependentGCJob(JobType::VPRowGC, Config::GetInstance()->VP_Row_GC_Task_THRESHOLD) {}
};

class VPRowListDefragJob : public DependentGCJob {
 public:
    VPRowListDefragJob() : DependentGCJob(JobType::VPRowDefrag, Config::GetInstance()->VP_Row_Defrag_Task_THRESHOLD) {}
};

class EPRowListGCJob : public DependentGCJob {
 public:
    EPRowListGCJob() : DependentGCJob(JobType::EPRowGC, Config::GetInstance()->EP_Row_GC_Task_THRESHOLD) {}
};

class EPRowListDefragJob : public DependentGCJob {
 public:
    EPRowListDefragJob() : DependentGCJob(JobType::EPRowDefrag, Config::GetInstance()->EP_Row_Defrag_Task_THRESHOLD) {}
};
