/* Copyright 2019 Husky Data Lab, CUHK

Authors: Created by Chenghuan Huang (chhuang@cse.cuhk.edu.hk)
*/

#pragma once

#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "tbb/concurrent_queue.h"

#include "layout/concurrent_mem_pool.hpp"
#include "layout/mvcc_list.hpp"
#include "layout/mvcc_value_store.hpp"
#include "layout/property_row_list.hpp"
#include "layout/row_definition.hpp"
#include "layout/topology_row_list.hpp"
#include "utils/config.hpp"
#include "utils/mymath.hpp"
#include "utils/tid_mapper.hpp"

/* AbstractGCTask is the parent class for all GC tasks.
 * Each kind of GC task needs to implement the Execute() function according to its context. 
 */
class AbstractGCTask {
 public:
    virtual void Execute() = 0;

    // The cost of this task
    // For example, the cost of EPGCTask can be the length of the invisible list of EP versions
    // Currently, cost_ is always 1.
    int cost_ = 1;
};

/* IndependentGCTask is the parent class of GC tasks without dependency.
 * Currently, no extra members or functions need to be defined.
 */
class IndependentGCTask : public AbstractGCTask {
};

class GCTaskDAG;

/* DependentGCTask is the parent class of GC tasks with dependency.
 * Each dependent task is a vertex in the GCTaskDAG.
 * Thus, DependentGCTask need extra members and functions to support the features as a
 * vertex in the GCTaskDAG.
 */
class DependentGCTask : public AbstractGCTask {
 public:
    // upstream_tasks_ and downstream_tasks_ are used to maintain the topology of the DAG.

    // upstream_tasks_ stores the incoming neighbors (parent tasks)
    // When READY -> PUSHED, all of its upstream tasks's blocked_count_ will be increased by 1 (recursive).
    unordered_set<DependentGCTask*> upstream_tasks_;

    // downstream_tasks_ stores the incoming neighbors (parent tasks)
    // When EMPTY -> READY, all of its READY downstream tasks will be permenently deleted (recursive).
    unordered_set<DependentGCTask*> downstream_tasks_;

    /* READY: The task is ready to be pushed to the GCExecutor
     * PUSHED: The task has already been pushed to the GCExecutor 
     * EMPTY: The task is a empty task generated by its downstream task
     */
    enum class TaskStatus {
        READY,
        PUSHED,
        EMPTY
    };

    TaskStatus task_status_;

    // How many downstream tasks has been pushed out.
    // Notice that a task can be EMPTY or READY when blocked_count_ > 0
    // However, PUSHED and blocked_count_ > 0 is not allowed. (Error occurs)
    int blocked_count_;

    static GCTaskDAG* gc_dag_;

    // Called when the task is removed in DAG.
    virtual void PropagateDeletion() = 0;
    // Called when the task need to be blocked;
    // sum_of_cost_ will not count blocked tasks on.
    virtual void PropagateBlocking() = 0;
};

/* For each type of GC tasks, a static integer "sum_of_cost_" will be used to store 
 *
 */

// Erase a specific vid on vertex_map_
class EraseVTask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    vid_t context_;
};

// Free a VPRowList
class VPRowListGCTask : public DependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    // Task context
    PropertyRowList<VertexPropertyRow>* context_;
    // Task id
    vid_t vid_;
};

// Free a TopoRowList
class TopoRowListGCTask : public DependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    // Task context
    TopologyRowList* context_;
    // Task id
    vid_t vid_;
};

// Perform GC on V_MVCC
class VMVCCGCTask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    VertexMVCCItem* context_;
};

// Defrag a VPRowList
class VPRowListDefragTask : public DependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    // Task context
    PropertyRowList<VertexPropertyRow>* context_;
    // Task id
    vid_t id_;
};

// Defrag a TopoRowList
class TopoRowListDefragTask : public DependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    // Task context
    TopologyRowList* context_;
    // Task id
    vid_t id_;
};

// Erase a specific eid on out_e_map_
class EraseOutETask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    eid_t context_;
};

// Erase a specific eid on in_e_map_
class EraseInETask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    eid_t context_;
};

// Perform GC on VP_MVCC
class VPMVCCGCTask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    VPropertyMVCCItem* context_;
};

// Perform GC on E_MVCC without EPRowList
class EmptyEdgeGCTask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    EdgeMVCCItem* context_;
};

struct CompoundEPRowListID {
    eid_t eid;
    PropertyRowList<EdgePropertyRow>* ptr;

    vid_t GetAttachedVid() {
        return eid.in_v;  // src_v
    }

    bool operator== (const CompoundEPRowListID& right_id) const {
        return (eid == right_id.eid && ptr == right_id.ptr);
    }
};

struct CompoundEPRowListIDHash {
    size_t operator()(const CompoundEPRowListID& _r) const {
        return mymath::hash_u64(_r.eid.value() ^ (uint64_t)_r.ptr);
    }
};

struct VidHash {
    size_t operator()(const vid_t& _r) const {
        return mymath::hash_u64(_r.value());
    }
};

// Perform GC on E_MVCC with EPRowList
class EdgeEntityGCTask : public DependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    // Task context
    EdgeMVCCItem* context_;
    // Task id
    CompoundEPRowListID id_;
};

// Defrag a EPRowList
class EPRowListDefragTask : public DependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    // Task context
    EdgeMVCCItem* context_;
    // Task id
    CompoundEPRowListID id_;
};

// Perform GC on EP_MVCC
class EPMVCCGCTask : public IndependentGCTask {
 public:
    static int sum_of_cost_;
    void Execute() override;
    EPropertyMVCCItem* context_;
};

class GCJob {
    vector<AbstractGCTask*> tasks_;

    // Call Execute() of tasks
    void Execute();
};

/*
 * 
 */
// The container of dependent tasks
class GCTaskDAG {
 private:
    GCTaskDAG() {}
    GCTaskDAG(const GCTaskDAG&);
    ~GCTaskDAG() {}

 public:
    static GCTaskDAG* GetInstance() {
        static GCTaskDAG task_dag;
        return &task_dag;
    }
    // The "adjacent list" is stored in the tasks objects (upstream_tasks_, downstream_tasks_).

    /* In the DAG, if a task exists, its parent task must exists.
     * Thus, when a task is inserted by the GCScanner and its parent task does not exists in the DAG,
     * an empty parent task will be inserted.
     */ 

/*
Task dependency DAG 1:
    VPRowListGCTask ----> VPRowListDefragTask
*/
    unordered_map<vid_t, VPRowListGCTask*, VidHash> vp_row_list_gc_tasks_;
    unordered_map<vid_t, VPRowListDefragTask*, VidHash> vp_row_list_defrag_tasks_;

    void InsertVPRowListGCTask(vid_t, PropertyRowList<VertexPropertyRow>*);
    void InsertEmptyVPRowListGCTask(vid_t);
    void InsertVPRowListDefragTask(vid_t, PropertyRowList<VertexPropertyRow>*);

    /* For example, when vp_row_list_gc_tasks_ and vp_row_list_defrag_tasks_ is empty,
     * and a VPRowListDefragTask (call it vprl_d0) (with vid = v0) is generated by GCScanner:
     *      First, insert <v0, vprl_d0> into vp_row_list_defrag_tasks_.
     *      Second, VPRowListGCTask with vid = v0 is not found in vp_row_list_gc_tasks_.
     *          
     */

/*
Task dependency DAG 2:
    TopoRowListGCTask ----> TopoRowListDefragTask
                     \
                      \
                       \
                        \
                         \
                          ->
    EdgeEntityGCTask ----> EPRowListDefragTask
*/
    unordered_map<vid_t, TopoRowListGCTask*, VidHash> topo_row_list_gc_tasks_;
    unordered_map<vid_t, TopoRowListDefragTask*, VidHash> topo_row_list_defrag_tasks_;
    unordered_map<CompoundEPRowListID, EdgeEntityGCTask*, CompoundEPRowListIDHash> edge_entity_gc_tasks_;
    unordered_map<CompoundEPRowListID, EPRowListDefragTask*, CompoundEPRowListIDHash> ep_row_list_defrag_tasks_;

    void InsertTopoRowListGCTask(vid_t, TopoRowListGCTask*);
    void InsertEmptyTopoRowListGCTask(vid_t);
    void InsertTopoRowListDefragTask(vid_t, TopoRowListGCTask*);
    void InsertEdgeEntityGCTask(CompoundEPRowListID, EdgeMVCCItem*);
    void InsertEmptyEdgeEntityGCTask(CompoundEPRowListID);
    void InsertEPRowListDefragTask(CompoundEPRowListID, PropertyRowList<VertexPropertyRow>*);

     // The GCScanner should guarantee that if a task is not empty, it won't grow sub-tasks
};
