/* Copyright 2019 Husky Data Lab, CUHK

Authors: Created by Chenghuan Huang (chhuang@cse.cuhk.edu.hk)
         Modified by Changji LI (cjli@cse.cuhk.edu.hk)
*/

#pragma once

#include <thread>

#include "layout/gc_consumer.hpp"
#include "layout/gc_task.hpp"

/*
The Scanning procedure:
  Notes: A single line means "one to one";
         Double lines means "one to many";

    vertex_map
        ||
        ||
        ||
      Vertex----------------------------MVCCList<V>
         |               |
         |               |
         |               |
    VPRowList       TopoRowList
        ||               ||
        ||               ||
        ||               ||
     VPHeader        EdgeHeader
         |               |
         |               |
         |               |
    MVCCList<VP>    MVCCList<E>
                         ||
                         ||
                         ||
                    EdgeMVCCItem
                         |
                         |
                         |
                        Edge
                         |
                         |
                         |
                     EPRowList
                         ||
                         ||
                         ||
                      EPHeader
                         |
                         |
                         |
                    MVCCList<EP>

*/

/* GCProducer encapsulates methods to scan the whole data layout and generate garbage collection tasks to
 * free memory allocated for those objects that are invisible to all transactions in the system.
 *
 * In GCProducer, a single thread will regularly scan the whole data layout and generates GC tasks.
 * If the sum of costs of a specific type of GC task has reach the given threshold, all tasks of this
 * type will be packed as a Job and push to GCExecutor.
 *
 * GCProducer maintains containers of tasks without dependency. For tasks with dependency, their containers
 * are in GCTaskDAG.
 */

// Fake one;
static int MINIMUM_ACTIVE_TRANSACTION_BT = 0;

class GCProducer {
 public:
    static GCProducer* GetInstance() {
        static GCProducer producer;
        return &producer;
    }

    void Init();
    void Stop();

    // The function that the GCProducer thread loops
    void Scan();
    /*
    void ScanVertexMap();
    void ScanVPRowList(PropertyRowList<VertexPropertyRow>*);
    bool ScanVPMVCCList(MVCCList<VPropertyMVCCItem>*);
    void ScanTopoRowList(TopologyRowList*);
    bool ScanEdgeMVCCList(MVCCList<EdgeMVCCItem>*);
    void ScanEPRowList(PropertyRowList<EdgePropertyRow>*);
    bool ScanEPMVCCList(MVCCList<EPropertyMVCCItem>*);
    */

    // In case of passing parameter
    /*
    vid_t current_vid_;
    eid_t current_eid_;
    */

    // Independent tasks are managed here
    /*
    vector<EraseVTask*> erase_v_map_tasks_;
    vector<VMVCCGCTask*> v_mvcc_gc_tasks_;
    vector<EraseOutETask*> erase_oute_map_tasks_;
    vector<EraseInETask*> erase_ine_map_tasks_;
    vector<VPMVCCGCTask*> vp_mvcc_gc_tasks_;
    vector<EmptyEdgeGCTask*> empty_edge_gc_tasks_;
    vector<EPMVCCGCTask*> ep_mvcc_gc_tasks_;
    */

    // void PushJob(vector<AbstractGCTask>&);

 private:
    GCProducer() {}
    GCProducer(const GCProducer&);
    ~GCProducer() {}

    // The container of dependent tasks
    class GCTaskDAG {
     private:
        GCTaskDAG() {}
        GCTaskDAG(const GCTaskDAG&);
        ~GCTaskDAG() {}

     public:
        static GCTaskDAG* GetInstance() {
            static GCTaskDAG task_dag;
            return &task_dag;
        }
        // The "adjacent list" is stored in the tasks objects (upstream_tasks_, downstream_tasks_).

        /* In the DAG, if a task exists, its parent task must exists.
         * Thus, when a task is inserted by the GCScanner and its parent task does not exists in the DAG,
         * an empty parent task will be inserted.
         */ 

        /*
        Task dependency DAG 1:
            VPRowListGCTask ----> VPRowListDefragTask
        */
        unordered_map<vid_t, VPRowListGCTask*, VidHash> vp_row_list_gc_tasks_;
        unordered_map<vid_t, VPRowListDefragTask*, VidHash> vp_row_list_defrag_tasks_;

        void InsertVPRowListGCTask(vid_t, PropertyRowList<VertexPropertyRow>*);
        void InsertEmptyVPRowListGCTask(vid_t);
        void InsertVPRowListDefragTask(vid_t, PropertyRowList<VertexPropertyRow>*);

        /* For example, when vp_row_list_gc_tasks_ and vp_row_list_defrag_tasks_ is empty,
         * and a VPRowListDefragTask (call it vprl_d0) (with vid = v0) is generated by GCScanner:
         *      First, insert <v0, vprl_d0> into vp_row_list_defrag_tasks_.
         *      Second, VPRowListGCTask with vid = v0 is not found in vp_row_list_gc_tasks_.
         *          
         */


        /*
        Task dependency DAG 2:
            TopoRowListGCTask ----> TopoRowListDefragTask
                             \
                              \
                               \
                                \
                                 \
                                  ->
            EdgeEntityGCTask ----> EPRowListDefragTask
        */
        unordered_map<vid_t, TopoRowListGCTask*, VidHash> topo_row_list_gc_tasks_;
        unordered_map<vid_t, TopoRowListDefragTask*, VidHash> topo_row_list_defrag_tasks_;
        unordered_map<CompoundEPRowListID, EdgeEntityGCTask*, CompoundEPRowListIDHash> edge_entity_gc_tasks_;
        unordered_map<CompoundEPRowListID, EPRowListDefragTask*, CompoundEPRowListIDHash> ep_row_list_defrag_tasks_;

        void InsertTopoRowListGCTask(vid_t, TopoRowListGCTask*);
        void InsertEmptyTopoRowListGCTask(vid_t);
        void InsertTopoRowListDefragTask(vid_t, TopoRowListGCTask*);
        void InsertEdgeEntityGCTask(CompoundEPRowListID, EdgeMVCCItem*);
        void InsertEmptyEdgeEntityGCTask(CompoundEPRowListID);
        void InsertEPRowListDefragTask(CompoundEPRowListID, PropertyRowList<VertexPropertyRow>*);

        // The GCScanner should guarantee that if a task is not empty, it won't grow sub-tasks
    };

    GCTaskDAG * gc_task_dag_;
    DataStorage * data_storage_;

    // GCJob<EraseVTask> erase_v_job;

    // Thread to scan data store
    thread scanner_;

    // Scanning Function
    void scan_vertex_map();
    void scan_topo_row_list(TopologyRowList*);
    void scan_ep_row_list(EdgeMVCCItem* edge_version);

    // Scan MVCCList
    template <class PropertyRow>
    void scan_prop_row_list(PropertyRowList<PropertyRow>* prop_row_list);
    template <class MVCCItem>
    bool scan_mvcc_list(MVCCList<MVCCItem>* mvcc_list);

    // Task spawning function
    void spawn_vertex_map_gctask(uint32_t* vid_value);
    void spawn_v_mvcc_gctask(VertexMVCCItem*);
    void spawn_vp_row_list_gctask(PropertyRowList<VertexPropertyRow>*);
    void spawn_vp_row_defrag_gctask(PropertyRowList<VertexPropertyRow>*, int cost);
    void spawn_vp_mvcc_list_gctask(VPropertyMVCCItem*);
    void spawn_topo_row_list_gctask(TopologyRowList*);
    void spawn_topo_row_list_defrag_gctask(TopologyRowList*);
    void spawn_edge_erase_gctask(uint64_t eid_value);
    void spawn_edge_mvcc_list_gctask(EdgeMVCCItem*);
    void spawn_ep_row_list_gctask(PropertyRowList<EdgePropertyRow>*);
    void spawn_ep_row_defrag_gctask(PropertyRowList<EdgePropertyRow>*);
    void spawn_ep_mvcc_list_gctask(EPropertyMVCCItem*);

};

#include "layout/gc_producer.tpp"
